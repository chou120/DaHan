package com.banyuan.oop6;

/**
 * @author sanye
 * @version 1.0
 * @date 2020/3/11 1:34 下午
 */
public class ExtendsDemo {

  /**
   * public     任意包的任意类都可以访问
   * protected  可以在不同的包的子类中被访问 其他的类不能访问
   * 默认        同一个包的子类访问
   * private    只能在本类中访问
   */

      /*
         私有化的成员能不能被继承？私有化的成员不能被继承
       * 那么如果去使用父类中私有化的成员: 通过继承父类的公有化方法区访问
       *
       * 注意:除了私有化的成员都可以被继承
       *
       * 问题:创建子类对象的时候 父类做了什么事情? 父类在创建子类对象之前先创建了对象
       * 那么请问,为什么创建子类对象之前要先创建父类对象？
       *  为了对父类成员的引用...
       *  那么如何去引用父类对象的   super
       *
       *  父类如果没有无参构造器 只有有参 那么 子类里面分无参构造并不能够访问父类的无参构造会报错
       * (除非在子类的无参构造里面去调用父类的有参构造器)
       *
       *  父类构造函数会不会被继承? 父类的构造函数不会被继承   super() 调用父类的无参构造
       *  构造函数不存在继承
       *
       * 问题: 1.父类和子类如果同时出现相同的成员(变量和方法)  怎么确定调用的是父类还是子类的成员(变量和方法)
       *    结论1:如果父类和子类同时出现相同的成员变量名,那么优先使用子类自己的
       *    结论2:如果同时出现相同的方法名时,还有优先使用子类自己的(不考虑静态方法)

         问题:父类有show   子类有show方法  请问 子类继承了父类的show方法嘛?
                没有继承父类 show方法
                如果子类和父类的方法名参数列表返回类型一致 表名子类重写了父类的方法

        问题: 静态方法能不能被重写？可不可以被继承？

            静态方法是属于类成员不能被重写(多态)

            但是可以被继承

        super  表示父类对象   super() 表示对父类对象的无参构造器的引用

        this   表示当前对象   this() 表示引用当前对象的无参构造器

        a.子类使用有参构造创建对象的时候  如果子类的有参构造器里面没有super(参数...)那么就意味着
        默认的去访问父类的无参构造器
        b.如果想要通过子类的有参构造器去给父类的成员变量进行赋值,那么要在子类的有参构造器里面添加指向父类
        的有参构造器   super(参数列表);


       */


  // 继承
  public static void main(String[] args) {
//    Teacher  teacher=new Teacher();
//    System.out.println(teacher.toString());

    Student  student=new Student();
    student.setName("李扣篮");
    student.setAddress("芝加哥");

    System.out.println(student.country+","+student.city);

    //student.show();
    //student.test();

    Student.test();

  }

}
